# Scratch pad
# Write your ideas about how to put the pieces together here.


                    #1 Graphical-User interface (GUI)
                    =================================

LoginWindow
===========
Reads in users' username (normally the email address) and password for icloud
server.
If "Save Credentials" checkbox is checked the first time user logs in password
and username are saved.
Next time the same username is typed in (or auto filled by application) the
password is filled automatically.
Note that we have no way of verifying the correctness of the credentials until
we try to actively login to icloud's calendar server.
If a username we have a record of (previously saved) is re-entered with a
different password, and "Save Credentials" checkbox is checked we update the
saved password for the user.  If the checkbox is not checked, credentials are not
updated.
NOTE: For the time being I am going to save user credentials in "data/"
directory.  But later, we need to modify the application so that the user can
select where his/her credentials will be saved.


UploadWindow
============
Two mutually exclusive checkboxes to select what type of roster user is going to
upload: term roster or a week roster.
Then "Upload Roster" button is enabled to select the roster file. This file is an
excel spreadsheet (*.xlsx).
"Enter" button is enabled once roster is updated.


NameSelectWindow
================
Centered around a combobox widget which is populated with the names in the
uploaded work roster.
User needs to select his/her name from the list.
There is a checkbox "Remember Me" to save the selected username.
If this is the first time the user logs in and the checkbox is checked, we save
the selected name against the username. If not and the username is known and a
name in the list is the one user selected previously, we auto select the combobox
with this name.
If a known user selects a different name we update this name as the one the last
used. We could potentially save all the names the user selected.  We could
either sort them according to recency or frequency of use.


Saving user credentials
-----------------------
We will get the hash of username (?MD5) and save credentials with this filename.
For example, akalankae@gmail.com gives MD5: 262f29a2e0b85a75a31f416da3cf8401.
So the credentials would be saved in 262f29a2e0b85a75a31f416da3cf8401.txt
Data should probably be in some non readable format for security, but first we
will save it as a text file for simplicity. Remember to change this to a data
file later, possibly using `pickle` module.


Source code Documentation
-------------------------
Have good documentation for functions for maintainability.
Suggest following topics in function doc string.
1) Interface (API)
    a. Parameters
    b. Return value
2) Assumptions
3) Errors
4) Caveats


TODO:

GUI design: Explore the possibility of using QStackedLayout with 3 windows
instead of 3 separate windows: LoginWindow, UploadWindow & NameSelectWindow

Autofill username: create a directory (something like "credentials") in target
directory used to store user credentials, read all files stored here and get a
list of previously used usernames to go through.

Autofill password


                    #2 PARSING EXCEL FILES
                    ======================

- Use openpyxl package to read excel files.
- Need to generate a data structure to hold shifts of the user.


Analysis of the term roster
---------------------------
First column has following:
- shift time symbols/time slots vs count of people for relevant slot
- "sick relief" vs number of people (if any) for particular day
- "Date" vs list of dates for the term from start to end of term
- "Day" vs name of the day for each day
- names of people rostered
- names are grouped according to level of supervision, names for each level are
  preceded by the label for that level (e.g. Level 3 (Red TL), Level (Red TL) -
  Non-ACEM)

Subsequent columns are grouped as 14-day sets for pay periods. In between
these groups are columns of metadata for number of shifts each person had to do
for that pay period.

Ideas
-----
I need to find out which column the names are in. After that need to figure out
the relevant column for the user.
Names are not consistent. Usually its "FIRSTNAME SURNAME", but sometimes there
are some labels following the name. E.g. John Doe - UKSRMO, Jane Doe (SRMO) You
need to recognise strings as names while making reservations for these
inconsistencies.
Analysis of names:
- has at least 2 space separated strings
- each string starts with a uppercase letter
- each string has more than 1 character
- characters after first character could be lowercase or one of few alphabetical
  characters such as hyphen (-), single quote (')
- when hyphen (-) has space on both before and after it cannot be belonging to a
  name

Sometimes the "Date" label is absent from the column. But I can figure out which
row this is because it is the only row with dates.
If you go through cells of each row of a worksheet, you can find "date" row by
virtue of having 7 to 14 cells with date instances next to each other. With
openpyxl you can inspect the `is_date` data attribute of a cell to verify if the
data in a cell is a date.
I could write a function that takes the worksheet as input and give the
numerical value of the row (starting from 1) that has the dates. I could return
0 (or -1) if the function is unable to figure out which row has the dates.

Some cells have shift time symbols (e.g. D, E, N). But sometimes you can find all
kinds of symbols there, so you need to be prepared for this.
If no shift fall on a date it usually has `None` value. But sometimes this is
given as "OFF" or empty string or even as a string with only white space.

Some shift labels in the roster are inexplicable. Whereas things like "D" for
day and "N" for night are known, it may contain strange things like "D - sick"
to mean sick leave for a day shift. The best approach to handle this I think is
to show them to the user and get them to enter how to interpret them. We can also
keep a record of how the user wanted them to be represented as, so that we can
recognize them later.

Show the user the known labels and their meanings and give them a chance to
modify them if needed. Important in case user entered a wrong meaning for a
label on a previous run.

Calendar
--------
The user should have the option to select which calendar to enter his/her shifts
into. But we can use a default calendar, like "Roster".

Events
------
Some times there are labels in the roster for leave or off days. For example
"OFF" or "AL" (for academic leave). These do not need to be entered in the
roster for the user, so we can give the option of choosing which labels the user
wants to ignore.

NOTE: DESCRIPTION property of a VEVENT appears on icalendar app under the
heading "notes".

How to detect events as shifts?
-------------------------------
Approach #1: Use a separate calendar

Approach #2: Use UID and/or other properties
- UID (Unique ID) - standard property
Has to be deterministic.
This is the most reliable way to detect shifts by scanning the calendar.
We can use this to scan the calendar and detect identical shifts, so that we
don't have to change them.

e.g.
[format]    Application Namespace:Employer ID:Employee ID:DAY OF SHIFT
[example]   ShiftWeaver:SWSLHD:60316064:20230820T080000Z
[MD5]       d36632223238ea07c7ba4e99a29b909e

- X-PROPERTIES - non-standard custom properties prefixed with "X-"
e.g.
X-SHIFT-ID:20230820/DAY
X-EMPLOYEE-ID:SWSLHD
X-PUBLISHED-BY:ShiftWeaver/v1.0

- CATEGORIES - standard
e.g.
CATEGORIES:Work Shift,EMPLOYMENT

- DESCRIPTION/COMMENT

UUID
----
RFC 4122 recommends using SHA1 as hash algorithm.
This is how you generate the UID:
- It has 2 parts: (1) Namespace string (2) Shift data string
- Namespace string is used to generate a namespace UUID and then hard-code it
  for use.
- This is done with uuid.uuid1() or uuid.uuid4() (but latter is better)
- Use uuid.UUID(namespace_string) to generate namespace UUID (NAMESPACE_UUID)
- Copy and paste into the application for use by all users.
- Generate full UUID with uuid.uuid5(NAMESPACE_UUID, shift_string)
- This will get a RFC 4122 compliant UUID.
